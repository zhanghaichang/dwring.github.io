---
layout: post
title: 你必须理解的计算机核心概念
category: other
tags: [other]
---
计算机学科中有很多概念， 例如编码(原码，补码，反码)， 虚拟内存， 文件， IO, 编译，链接，分组交换，关系， 事务，范式， Hash, 加密。。。等等，本文试图讲一下最重要的核心集合，从这个集合当中就可以变换出计算机编程的各种魔法。

**1 冯·诺依曼结构计算机的原理**

所有的计算机语言，不管是Java, Python, Go, C, C++, PHP...... ， 无论你在TIOBE上是排行第一还是排行第100, 无论看起来多么花哨，功能多么强大，用起来多么舒服， 最终都要变成基本的二进制指令，老老实实地在冯·诺依曼结构计算机上按规矩执行。

这里是根， 我们看到的、用到的都是这棵树上的花和枝叶。

作为志向远大的、有着强烈好奇心的年轻人， 难道你不想到根部来看一看?

作为最基本的要求， 必须要了解CPU和内存这俩哥们是怎么亲密无间工作的： CPU从内存取出指令，进行译码和执行，执行时从内存中取出数据放到寄存器中， 进行计算， 然后把结果写回到内存。如果是跳转指令， CPU则取出跳转目的地的指令继续执行。

如此简单的过程，竟然组成了多姿多彩的电脑世界： 你可以听音乐，玩游戏、上网聊天、用Word来写文档..... 当然看起来微不足道的一个操作，进入到CPU和内存中都可能需要成千上万条指令来完成。

这些基本的指令组成了顺序、循环、分支等基本的程序结构，形成了更为强大的编程语言的基础。

CPU和内存、硬盘等设备的速度不匹配，是冯·诺依曼结构计算机的一个核心问题，为了解决这个问题，科学家们绞尽脑汁，想尽了办法， 又引出了一堆概念： 缓存，DMA， 同步，异步，阻塞....

**2 进程和线程**

这俩家伙的重要性不言而喻，因为你写的所有的程序要么会成为一个独立的进程去执行，要么是被一个进程中的线程收编，没有例外 。

几乎所有的编程语言都会涉及到对多进程或者多线程编程的支持， 特别是多线程的并发编程， 所以你必须得搞明白它的本质是什么。

进程是对一个运行中的程序的抽象，没有这个概念，我们是无法实现一边听歌、一边上网的惬意生活。

对于CPU来讲， 它只是“浑浑噩噩”地从某个地方取指令，译码执行，但是它不会意识到在某一刻整个世界已经变了天， 它执行的程序已经发生了切换，另外一个程序(准确地讲叫进程)已经成功地抢班夺权。

每个进程都有一个被操作系统老大维护的进程控制块， 里边保存了这个进程在运行时的重要信息，是进程能来回切换的重要保证。

而线程则寄居于进程之内 ， 共享进程提供福利(代码和数据)的同时， 还拥有自己的一亩三分地。

[![](http://s4.51cto.com/wyfs02/M01/9B/E4/wKiom1loaw7z1yA1AADOILU9u1o116.jpg)](http://s4.51cto.com/wyfs02/M01/9B/E4/wKiom1loaw7z1yA1AADOILU9u1o116.jpg)

线程的出现，提升了系统的性能、吞吐量和响应性。 但是多进程/多线程编程也带来了一系列问题： 同步，通信，锁， 死锁。。。

**3 虚拟内存**

有了物理内存， 为啥还有虚拟内存?

一个重要的原因就是给各位进程先生提供一个由虚拟地址组成的独立王国，　给他们造成一种假象：　我最重要，我是独占内存的!

每个人在自己的独立王国里闹腾，就不会互相打架， 治安也就有了保证。

但是在虚拟地址王国里做不了什么事情，指令必须在物理内存中才能被执行， 操作系统老大用尽浑身解数，把每个进程的虚拟地址映射到实际地址上去，表面上不动声色，背后绝对惊心动魄，分段，分页，页表，还要动用CPU的TLB来加速。

程序并不是像你想象的那样，一下子全部装载到内存的， 而是慢慢地， 用到的时候才进行装载。

进程一条普通指令的执行， 其实有一大家子在鞍前马后地忙碌着， 而进程几乎浑然不觉，真是太幸福了。

**4 网络的核心概念**

上面所说的都局限于一台计算机， 然而一张大网早已经把这些孤岛联系在一起。

这张大网就你我的周围， 我们都变成了它的一个节点。

大网的设计非常有趣，没有一个中心的节点，某几个甚至某一片节点阵亡都没有关系，大网继续生存，提供服务。

作为码农我们要理解的核心概念是： 分组交换， TCP/IP参考模型， socket , http(s)。

你也许没有想到，你上网玩游戏，听音乐，看这篇文章，其中的数据并不是一下子全发给你的， 而是被切分成适合网络传输的小块，给每个小块编上号， 每个小块都独立地走相同甚至不同的网络路径， 到达你这里，重新排序，组合，然后才展示给你， 这就是分组交换。

使用分组交换可以充分的利用网络带宽： 在你不使用的间隙，别人也可以利用。

但是一个很明显的问题就是分组数据丢失了怎么办? 如何检测， 怎么重发，如何缓存已经收到分组数据等一系列烦人的问题接踵而来。 这就是TCP要干的事情。

如果你能体会到TCP是在端系统实现的，中间节点一无所知，我想你就Get到了分组交换和分层的真谛。

TCP/IP参考模型定义了5层： 应用层，传输层，网络层，链路层，物理层。你一定得理解所谓的分层只不过是把你的数据层层包装而已，在传输的过程层中每到一个节点都会拆开某一层的包装，查看一下数据， 然后再次包装，转发出去，直到终点。

也许你不愿意了解底层烦人的细节， 但是一定要理解socket和http(s) ， 这哥俩最贴近我们码农的日常生活，我们经常直接和他们对话，利用他们收发数据， 所以花点经历好好学学吧。

**5 Hash 和 RSA**

如果说Https是网络安全通信的一大基石， 那Hash和RSA 则是基石的基石。

为了保证消息在传输过程中的私密性， 完整性，不可伪造性，这哥俩可以说是功不可没。

其实不仅仅是Https , 在各种软硬件平台上都能看到他们勤奋的身影， 例如SSO, SSH, JWT ..... 所以非常值得你投入精力去学习。

RSA最为美妙之处就是有一对儿钥匙， 一个是私有的、保密的， 另外一个是公有的， 谁都可以知道， 这对于之前的对称密钥是个极大的颠覆， 谁能想到原先需要保密的密钥竟然可以公开呢!

更有意思的是私钥加密的数据只有相应的公钥才能解开， 反之亦然，这确实是很漂亮的概念。

RSA的概念很简单， 但是为了实现真正的安全消息传输，作为第一步必须得有数据签名做保证， 你需要理解如何对消息用Hash形成摘要，然后用私钥签名，又是如何验证这个签名的， 理解了这一点，很多东西都迎刃而解。
